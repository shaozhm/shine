'use strict';

const archiverProxy = require('./archiver-proxy'),
      glob = require("glob"),
      fs = require('fs'),
      request = require('request'),
      util = require('util');

class DeployTasksManager {

    constructor(options) {
        this.options = options;
        this.tasksResult = {};
    }

    archiveProject(cb) {
        try {
            var archiver = archiverProxy.getArchiver();
            let buildDirectory = this.options.workingDir +  '/deploymentTemp';
            let buildFile = buildDirectory +  '/archive.zip';

            if (!fs.existsSync(buildDirectory)){
                fs.mkdirSync(buildDirectory);
            }

            var output = fs.createWriteStream(buildFile);

            let envData = {};
            envData.destinations = this.tasksResult.destinations || {};
            envData = this.tasksResult.env || {};

            var req;

            var archive = archiver('zip', {
                store: true // Sets the compression method to STORE.
            });

            // listen for all archive data to be written
            output.on('close', function() {
                console.log(archive.pointer() + ' total bytes');
                console.log('Build deployment zip finished');
                this.tasksResult.archive = buildFile;
                cb();
            }.bind(this));

            // good practice to catch this error explicitly
            archive.on('error', function(err) {
                cb(err);
            });

            // pipe archive data to the file
            archive.pipe(output);
            let pattern = this.options.workingDir + "/**";
            glob(pattern,  { ignore: ["**/node_modules/**", "**/deploymentTemp/**", "**/*.js", "**/*.css"]}, (err, files) => {
                files.forEach((file) => {
                    if (!fs.lstatSync(file).isDirectory()) {
                        archive.file(file, {name: file.substring(this.options.workingDir.length +1, file.length)});
                    }
                });
                archive.append(JSON.stringify(envData), { name : 'envDetails.json'});
                archive.finalize();
            });
        } catch (err) {
            cb(err);
        }
    }

    readDestinationsTask(cb) {
        try {
            this.tasksResult.env = this.tasksResult.env || {};
            this.tasksResult.env.destinations = JSON.parse(process.env.destinations || '[]');
            console.log('Read destinations task finished');
            cb();
        } catch (err) {
            cb(err);
        }
    }

    readEnvironmentVariablesTask(cb) {
        try {
            this.tasksResult.env = this.tasksResult.env || {};
            this.tasksResult.env.VCAP_APPLICATION = process.env.VCAP_APPLICATION;
            this.tasksResult.env.VCAP_SERVICES = process.env.VCAP_SERVICES;
            console.log('Read Environment task finished');
            cb();
        } catch (err) {
            cb(err);
        }
    }

    deploy(cb) {
        try {

            let persistHeaders = createHeadersForPersist(this.options);

            var formData = {
                deployData: fs.createReadStream(this.tasksResult.archive)
            };

            request.put({
                    url: persistHeaders.url,
                    formData: formData,
                    headers: persistHeaders.headers,
                    timeout: 15000
                },
                (error, response, body) => {
                    clean(this.tasksResult.archive);
                    if (!error && response && response.statusCode != 200) {
                        error = response.statusCode;
                    }
                    if (!error) {
                        console.log('Data deployed successfully...');
                    }
                    cb(error);
                }
            );
        } catch (err) {
            clean(this.tasksResult.archive);
            cb(err);
        }
    }
}

module.exports = DeployTasksManager;

function createHeadersForPersist(options) {
    let dataForPersist = {};
    let credentials = getPortalServicesCredentials(JSON.parse(process.env.VCAP_SERVICES)).credentials;
    let authHeader = 'Basic ' + new Buffer( credentials.user + ':' + credentials.password).toString('base64');
    dataForPersist.url = credentials.url + options.relativeImportUrl;
    dataForPersist.headers = {
        'instanceId': credentials.instanceId,
        'bindingId': credentials.bindingId,
        'Authorization': authHeader,
        'deploymentType' : options.deploymentType
    };
    return dataForPersist;
}

function getPortalServicesCredentials(services) {
    for (var property in services) {
        if (services[property] && services[property][0] && services[property][0].tags) {
            var tags = services[property][0].tags;
            if (isArrayInclude(tags, "portal")) {
                return services[property][0];
            }
        }
    }
}

function isArrayInclude(arr, item) {
    var isFound = false;
    if (arr && item) {
        for (var index in arr) {
            if (arr[index] === item) {
                return true;
            }
        }
    }
    return isFound;
}

function  clean(name) {
    try {
        fs.unlink(name);
    } catch (err) {

    }
}
